```admonish warning 
**本章施工中**
```

<!-- toc -->

# 等价的计算模型
```admonish tip title="本章的学习目标"
- 了解RAM机（RAM Machine）与$\lambda$演算（$\lambda$ Calculus）
- 掌握这些模型与图灵机及其他模型的等价关系
- 认识元胞自动机（Cellular Automata）与各种图灵机格局
- 理解Church-Turing论题
```

```admonish quote title=""
“计算机科学的所有问题都可以通过增加一层间接寻址来解决”

*——大卫·惠勒（David Wheeler）*
```

```admonish quote title=""
“由于后续我们将使用函数表达式进行计算，必须区分函数与形式，并需要相应的表示法。这一区分及其描述记法由Church提出，我们仅作细微调整。”

*——约翰·麦卡锡（John McCarthy），1960年（摘自描述LISP编程语言的论文）*
```

到目前为止，我们已经定义了使用图灵机计算函数的概念，但这与实际的计算方法并不完全吻合。本章将通过证明可计算函数的定义在各种计算模型下保持不变，来论证这一选择的合理性。这一概念被称为*图灵完备性*（Church completeness）或*图灵等价性*（Church equivalence），是计算机科学中最基本的事实之一。实际上，被广泛认同的*Church-Turing论题*做了出了如下主张：任何对可计算函数的“合理”定义，都等价于通过图灵机可计算的概念。我们将在[8.8节](#88-church-turing论题讨论)讨论Church-Turing论题以及“合理”的可能定义。

本章讨论的主要计算模型包括：

- **RAM机**：图灵机与具备随机存取存储器（RAM，Random Access Memory）的标准计算架构并不对应，RAM机的数学模型更接近实际计算机，但我们将看到它在计算能力上与图灵机等价。我们还将讨论RAM机的一种编程语言变体，称之为NAND-RAM。图灵机与RAM机的等价性使得我们能够证明诸多流行编程语言的图灵等价性，包括现实中使用的所有通用编程语言，如C、Python、JavaScript等。
- **元胞自动机**：许多自然的和人工的系统都可以被建模为简单组件的集合，每个组件根据其自身状态及其直接邻居的状态，按照简单的规则进行演化。一个著名的例子是[康威的生命游戏](https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life)（Conway's Game of Life）。为了证明元胞自动机与图灵机等价，我们将引入*图灵机格局*（configurations of Turing machines）。这些格局还有其他应用，特别是在[第11章](./chapter_11.md)用于证明哥德尔不完备定理——数学中的一个核心结果。
- $\lambda$**演算**：$\lambda$演算是一种表达计算模型，起源于20世纪30年代，不过它与当今广泛使用的函数式编程语言密切相关。证明$\lambda$演算与图灵机等价涉及一种名为“Y组合子”（Y Combinator）的消除递归的巧妙方法。

```admonish tip title="本章的一个非数学化概览"
本章中我们将研究不同模型间的等价性。如果两个计算模型能够计算的函数构成的集合是相同的，则称它们是*等价*的（也称之为*图灵等价*）。例如，我们已经看到图灵机与NAND-TM程序是等价的，因为我们可以将每个图灵机转换为计算相同函数的NAND-TM程序，同样地，也可以将每个NAND-TM程序转换为计算相同函数的图灵机。

本章我们将证明这种等价性远不止于图灵机。我们开发的技术使我们能够证明所有通用编程语言（即Python、C、Java等）都是*图灵完备的*，即它们能够模拟图灵机，因此能够计算所有图灵机可计算的函数。我们还将证明其反向亦成立——图灵机可以用来模拟用任何这些语言编写的程序，因此能够计算这些语言可计算的任何函数。这意味着所有这些编程语言都是*图灵等价*的：即它们在计算能力上等价于图灵机，并且彼此等价。这是一个强大的原理，是计算机科学广泛影响的基础。此外，它使我们能够“鱼和熊掌兼得”——既然所有这些模型都是等价的，我们可以为手头的任务选择方便的模型。为了实现这种等价性，我们定义了一种新的计算模型，称为RAM机。RAM机比图灵机更接近现代计算机的架构，但在计算能力上仍然与图灵机等价。

最后，我们将证明图灵等价性远不止于传统编程语言，作为极其简单的自然系统的数学模型的*元胞自动机*也是图灵等价的，并且我们还将看到$\lambda$演算的图灵等价性——$\lambda$演算是一种用于表达函数的逻辑系统，是Lisp、OCaml等*函数式编程语言*的基础。

本章成果概览见[图8.1](#i81)。
```

```admonish quote title="图8.1"
<span id="i81"> ![](./images/chapter8/turingcomplete.png)</span>
*一些图灵等价模型。所有这些模型在计算能力上都与图灵机（或等价的NAND-TM程序）等价，因为它们能够计算完全相同的函数类。所有这些模型都是用于计算接受无界长度输入的无限函数的模型。相比之下，布尔电路/NAND-CIRC程序只能计算有限函数，因此不是图灵完备的。*
```

## 8.1 RAM机与NAND-RAM

图灵机（以及NAND-TM程序）的一个局限性在于，我们每次只能访问数组或磁带的一个位置。如果磁头位于磁带的第$22$位，而我们想要访问第$957$个位置，那么我们至少需要$923$步才能到达该位置。相比之下，几乎每种编程语言都提供了直接访问内存位置的形式化方法。实际的物理计算机也提供了可以被视为一个大型数组`Memory`的*随机存取存储器*（RAM），给定索引$p$（即内存地址或*指针*），我们可以读取和写入`Memory`的第$p$个位置。（“随机存取存储器”这一名称实际上用词有误，因为它与概率无关，但既然这是计算理论与实践中的标准术语，我们也将沿用这一说法）。

中这种内存访问进行建模的计算模型是*RAM机*（有时也称为*字RAM模型*（Word RAM Model）），如[图8.2](#i82)所示。RAM机的内存是一个大小无界的数组，其中每个单元可以存储一个*字*（Word），我们将其视为$\{0,1\}^w$的字符串，同时（等价地）也视为$[2^w]$中的一个数字。例如，许多现代计算架构使用64位的字，每个内存位置保存一个$\{0,1\}^{64}$中的字符串，这也可以视为一个介于$0$到$2^{64}-1=18,446,744,073,709,551,615$之间的数字。参数$w$被称为*字长*（Word Size）。在实践中，$w$通常是一个固定数字（比如64），但在理论研究中，我们将$w$建模为一个可以依赖于输入长度或步骤数的参数。（你可以将$2^w$大致视为我们在计算中使用的最大内存地址。）除了内存数组，RAM机还包含恒定数量的*寄存器*（Register）$r_0,\dots,r_{k-1}$，每个寄存器也能保存一个字。

```admonish quote title="图8.2"
<span id="i82"> ![](./images/chapter8/ramvsturing.png)</span>
*RAM机包含有限数量的局部寄存器（每个寄存器保存一个整数）和一个无界的内存数组。它可以对寄存器执行算术运算，还可以将内存中由寄存器$r'$中的数字索引的地址的内容加载到寄存器$r$中。*
```

RAM机可以执行的操作包括：

- **数据移动**： 将内存中某个单元的数据加载到寄存器中，或将寄存器的内容存储到内存的某个单元。RAM机可以直接访问内存的任何单元，而无需像图灵机那样将“磁头”移动到该位置。也就是说，RAM机可以在一步中将由寄存器$r_j$索引的内存单元的内容加载到寄存器$r_i$中，或将寄存器$r_i$的内容存储到由寄存器$r_j$索引的内存单元中。
- **计算**： RAM机可以对寄存器执行计算，例如算术运算、逻辑运算和比较。
- **控制流**： 与图灵机一样，接下来执行什么指令的选择可以取决于RAM机的状态，这由其寄存器的内容捕获。

```admonish quote title="图8.3"
<span id="i83"> ![](./images/chapter8/rammachine.png)</span>
*RAM机和图灵机的不同方面。RAM机可以在其局部寄存器中存储整数，并且可以读取和写入由其寄存器指定的内存位置。相比之下，图灵机只能访问其磁头位置的内存，且磁头在每一步最多只能向右或向左移动一个位置。*
```

我们不会给出RAM机的正式定义，但参考文献部分（[第8.10节](#810-参考文献)）包含了这些定义的来源。正如NAND-TM编程语言模拟图灵机一样，我们也可以定义一种模拟RAM机的*NAND-RAM编程语言*。NAND-RAM编程语言通过添加以下特性扩展了NAND-TM：

- NAND-RAM的变量允许是（非负）*整数值*的，而不仅仅是NAND-TM中的布尔值。也就是说，标量变量`foo`保存的是$\N$中的非负整数（而不仅仅是${0,1}$中的一位），数组变量`Bar`保存的是一个整数数组。与RAM机的情况一样，我们不允许无界大小的整数。具体来说，每个变量保存一个介于$0$和$T-1$之间的数字，其中$T$是程序到目前为止已执行的步骤数。（你现在可以忽略此限制：如果我们想要保存更大的数字，可以简单地执行虚拟指令；这在后面的章节中会有用。）
- 我们允许对数组进行*索引访问*。如果`foo`是标量而`Bar`是数组，则`Bar[foo]`引用由`foo`的值索引的`Bar`的位置。（注意这意味着我们不再需要特殊的索引变量`i`。）
- 正如编程语言中常见的情况，我们假设对于布尔运算（如`NAND`），零值整数被视为*假*，非零值整数被视为*真*。
- 除了`NAND`之外，NAND-RAM还包括所有基本的算术运算：加、减、乘、（整数）除，以及比较（等于、大于、小于等）。
- NAND-RAM将条件语句`if`/`then`作为语言的一部分。
- NAND-RAM包含循环结构，例如`while`和`do`，作为语言的一部分。

NAND-RAM编程语言的完整描述见[附录](http://tiny.cc/introtcsappendix)。然而，关于NAND-RAM你需要了解的最重要的事实是你实际上并不需要太多了解NAND-RAM，因为它在能力上等同于图灵机：

```admonish quote title=""
{{thmc}}{thmc:t81}（图灵机（即 NAND-TM 程序）与 RAM 机（即 NAND-RAM 程序）的等价性）

对于每个函数 $F:{0,1}^* \rightarrow {0,1}^*$，$F$ 可由 NAND-TM 程序计算，当且仅当 $F$ 可由 NAND-RAM 程序计算。
```

由于NAND-TM程序等价于图灵机，而NAND-RAM程序等价于RAM机，{{tref:thmc:t81}}表明所有这四种模型彼此之间是等价的。

```admonish quote title="图8.4"
<span id="i84"> ![](./images/chapter8/nandramproofoverview.png)</span>
*使用NAND-TM模拟NAND-RAM的{{tref:thmc:t81}}证明步骤概览。我们首先使用[7.4.1节]()中的内部循环语法糖，使得能够将整数从数组加载到NAND-TM的索引变量`i`。一旦我们能这样做，我们就可以在NAND-TM中模拟索引访问。然后，我们利用$\N^2$到$\N$的嵌入，在NAND-TM中模拟二维位数组。最后，我们使用二进制表示将整数的一维数组编码为位的二维数组，从而完成使用NAND-TM对NAND-RAM的模拟。*
```

```admonish tip collapsible=true title="证明思路"
显然，NAND-RAM只会比NAND-TM更强大，因此如果一个函数$F$可由NAND-TM程序计算，那么它也能由NAND-RAM程序计算。具有挑战性的方向是将NAND-RAM程序$P$转换为等价的NAND-TM程序$Q$。要完整描述这个证明，我们需要涵盖NAND-RAM语言的完整形式化规范，并展示如何将其每一个特性实现为NAND-TM之上的语法糖。

这可以做到，但详细检查所有操作相当繁琐。因此，我们将着重描述此转换背后的主要思想。（另见[图8.4](#i84)。）NAND-RAM在两个方面推广了NAND-TM：**(a)** 增加了对数组的索引访问（即`Foo[bar]`语法），以及 **(b)** 从布尔值变量过渡到整数值变量。该转换有两个步骤：
1. *位数组的索引访问*： 我们首先展示如何处理 **(a)**。即，我们展示如何在NAND-TM中实现操作`Setindex(Bar)`，使得如果`Bar`是编码了某个整数$j$的数组，则在执行`Setindex(Bar)`后，`i`的值将等于$j$。这将允许我们通过`Setindex(Bar)`后跟`Foo[i]`来模拟`Foo[Bar]`这种形式的语法。
2. *二维位数组*： 接着，我们展示如何使用“语法糖”来为NAND-TM增加*二维数组*的功能。即，拥有*两个索引*`i`和`j`以及*二维数组*，使得我们可以使用语法`Foo[i][j]`来访问`Foo`的(`i`,`j`)位置。
3. *整数数组*： 最后，我们将一个*整数*的一维数组`Arr`编码为一个*位*的二维数组`Arrbin`。思路很简单：如果$a_{i,0},\ldots,a_{i,\ell}$是`Arr[`$i$`]`的一个二进制（无前缀）表示，那么`Arrbin[`$i$`][`$j$`]`将等于$a_{i,j}$。

一旦我们有了整数数组，我们就可以使用我们常用的函数语法糖、`GOTO`等来实现NAND-RAM的算术和控制流操作。
```

上述方法并非获得{{tref:thmc:t81}}证明的唯一途径，例如可参见[练习8.1]()。

```admonish note title="备注8.2：RAM机/NAND-RAM与汇编语言（可选）"
RAM机与现实中的微处理器（例如Intel x86系列中的那些）非常对应，这些微处理器也包含一个大的*主内存*和数量固定的少量寄存器。这当然并非偶然：与图灵机相比，RAM机旨在更贴近地模拟实际计算系统的体系结构，这种体系结构在很大程度上遵循了 ([von Neumann, 1945](https://scholar.google.com/scholar?hl=en&q=von+Neumann+First+Draft+of+a+Report+on+the+EDVAC)) 报告中描述的所谓[冯·诺依曼架构](https://en.wikipedia.org/wiki/Von_Neumann_architecture)。
因此，NAND-RAM在其大致轮廓上类似于x86或NIPS等汇编语言。这些汇编语言都具有以下指令：**(1)** 将数据从寄存器移动到内存，**(2)** 对寄存器执行算术或逻辑计算，以及 **(3)** 条件执行和循环（在汇编语言语境中通常称为“分支”和“跳转”的“if”和“goto”）。

RAM机与实际微处理器之间的主要区别（相应地，也是NAND-RAM与汇编语言之间的主要区别）在于，实际微处理器具有固定的字长$w$，因此所有寄存器和内存单元保存的都是$[2^w]$中的数字（或等价地，${0,1}^w$中的字符串）。这个数字$w$在不同的处理器中可能不同，但常见的值要么是$32$，要么是$64$。作为理论模型，RAM机没有这个限制，我们反而让$w$作为我们运行时间的对数（这也大致对应于其在实践中的值）。现实中的微处理器也具有固定数量的寄存器（例如，x86-64中有14个通用寄存器），但这与RAM机相比差别不大。可以证明，只有两个寄存器的RAM机与拥有任意大的常数数量寄存器的完整RAM机具有同等能力。

当然，现实中的微处理器也具有许多RAM机所不具备的特性，包括并行性、内存层次结构以及许多其他特性。然而，RAM机确实在初步近似下捕捉了实际计算机的特征，因此（正如我们将看到的），算法在RAM机上的运行时间（例如，$O(n)$对比$O(n^2)$）与其实际运行的效率高度相关。
```

## 8.2 具体细节（可选）

### 8.2.1 NAND-TM中的索引访问

### 8.2.2 NAND-TM中的二维数组

### 8.2.3 其他细节

## 8.3 图灵等价性（讨论）

### 8.3.1 “两全其美”的范式

### 8.3.2 浅谈抽象层次

### 8.3.3 图灵完备性与等价性的形式化定义（可选）

## 8.4 元胞自动机

### 8.4.1 一维元胞自动机的图灵完备性

### 8.4.2 图灵机格局与状态转移函数

## 8.5 $\lambda$演算与函数式编程语言

### 8.5.1 函数的高阶应用

### 8.5.2 通过柯里化实现多参数函数

### 8.5.3 $\lambda$演算的形式化描述

### 8.5.4 $\lambda$演算中的无限循环

## 8.6 增强$\lambda$演算

### 8.6.1 增强$\lambda$演算中的函数计算

### 8.6.2 增强$\lambda$演算的图灵完备性

## 8.7 从增强$\lambda$演算到纯$\lambda$演算

### 8.7.1 列表处理

### 8.7.2 Y组合子：不需要递归的递归

## 8.8 Church-Turing论题（讨论）

### 8.8.1 不同的计算模型

## 8.9 习题

## 8.10 参考文献